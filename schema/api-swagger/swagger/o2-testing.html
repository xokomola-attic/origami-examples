# Oxygen - Testing (#20593)

## Charter

Goals of this initiative:

- Less incidents preventable by testing
- Standard approach for CI
- Way of working described
- Story to the business

How does this relate to what I do?

- SocialNetworker content service (XML)
- RenderService currently uses various APIs for Order fulfillment (Alfresco OpenCMIS, SN API, SN XML API, external printer WS)
- Content services: XML API delivers documents, how can I access just the data I need. One recurring question, should I make this decision of what a client needs on the server or on the client (see also [Relay and GraphQL][NETFLIX], [Falcor and JSON Graph][FACEBOOK], [Demand Driven Architecture][DEMANDDRIVEN])
- How can I make sure that the XML API delivers what I say it does? XML schema and on-the-fly validation in the returned XML
- Can I and should I return JSON? XSLT currently cannot deal with JSON but what other clients need the data? XQuery 3.1 / XSLT 3.1 can now deal with JSON better.
- What content models do we provide? Can there be one world model? No!

In the rest of this memo I look at various tools that help us with developing APIs.

## Inventory (#20671)

### What do we need from API development tools?

I want API development tools to help me with:

- Specification & Design (there's a role for mocking here too)
- Documentation
- Validation (what & when?)
- Testing (mocking)
- Management & Versioning?

Concretely I probably need:

- Support different languages? Polyglot? Which ones?
- Generate client code (mock)?
- Generate server code (mock)?
- Generate API docs (how do we make this accessible for everyone?)
- Managing of multiple APIs

For our development and deployment processes I expect to have:

- DRY, how can we re-use code and message structures
- Patterns (ways of working) for developing APIs (shared knowledge)
- Do we give clients what they need? Do UI clients need the same APIs as non-UI web service clients?
- What do we require for each and every API that we deploy? What to drive via CI?
- DevOps aspects (public versus back-end APIs)?

See also:

- [Investigating Api Developer Tooling][APITOOLS]
- [Listing of mocking tools][MOCKTOOLS]

### API testing

The context of the rest of this memo is on designing and developing a very simple mock for a third-party service.

What I want to achieve:

- Specify the API once and use this code to generate mocking code and documentation.

What I have:

- An email with some details on how to call a vendor's simple REST API.

#### [curl][CURL] & [wget][WGET]

When to use: getting to know an existing API, exploratory testing: when developing a client or server API.

The use of these command-line tools is a bit bare bones and multiple example calls would have to be either scripted or documented for copy/pasting.

#### [PostMan][POSTMAN]

When to use: getting to know an existing API, exploratory testing: when developing a client or server API.

Postman is a separate Chrome application. HTTP call collections can be saved to JSON. Payed subscriptions get more testing related features.

### [Mock-Server][MOCKSERVER]

When to use: development and testing of an API consumer.

> MockServer is a robust mock HTTP server. It can be configured to respond to requests based on a variety of criteria, including headers and cookies, and can be configured to issue delayed or repeat responses. In addition to serving as a pure mock server, MockServer can be used as a proxy for the purpose of logging and debugging requests and responses.

I haven't actually used this yet but it seemed like something fit for further investigation.

It does not use Swagger and uses internal (Java/Groovy) DSL to specify service expectations. It also supports using an API proxy for analysing or working with legacy services or for recording and replaying service calls.

#### [SOAP-UI][SOAPUI]

I used it but found it too Java-centric and to cumbersome to quickly whip out a mock server. Maybe Java devs think otherwise. On the other hand it was not terribly difficult to get it to read a [Swagger][SWAGGER] or [RAML][RAML] description and generate most of the mock for me. However it didn't use the example response messages and I had to tweak it considerably in order to use it in real testing.

Currently we tend to use the SOAP UI project file as the mock. But this doesn't help us with description/documentation.

I had an API description but then I still need to have SOAP UI install a plugin and then finally we can only save the SOAP UI project which is not as useful as the spec itself.

##### Code

- `soap-ui/rapidity-soapui-project.xml`
- `soap-ui/wadl-report.html`
- `soap-ui/rapidity.wadl`
- `soap-ui/rapidity.raml`

#### [miredot][MIREDOT]

This is what is currently used for OM APIs.

- Seems to be popular *because* it's Java oriented and it's free (professional 300 EUR yearly)
- Mostly aimed at documentation not so much prototyping and testing
- Isn't as widely accepted as Swagger
- This cannot be used for other languages (XQuery, Javascript); not polyglot.

Although it more or less gives us what we want now. In my opinion it is too Java-centric (with explicit integration of the most popular REST frameworks)and if we have APIs in other languages we cannot use it. Also it doesn't do much for generating mock code.

#### [Apiary][APIARY]

- Very complete but not free (team license 99 USD monthly)
- Spans the whole development process (design, development, testing, documentation)
- Describe API using [API blueprint](https://apiblueprint.org/)

**API Blueprint** is the API description language and it seems simpler than Swagger YAML or JSON. But this can be misleading. It's basically a markdown dialect which gets parsed into JSON. Although Apiary offers validation tool (Ruby command-line tool).

#### [Swagger][SWAGGER]

Supports:

- Code generation for client
- Code generation for server

Get started with Swagger easily using the on-line [Editor](http://editor.swagger.io/#/).

There is a specification of the [Specification](http://swagger.io/specification) language.

##### Code

- `swagger-server/rapidity.yaml` (an API spec using Swagger YAML)

#### [swagger-server](https://www.npmjs.com/package/swagger-server)

When to use: generate API server mock.

With a Swagger description we can use this Node module to provide support for building a mock service. As with most other tools I tried you still need to do a little bit of work to hook it up with sample response messages. But this code should be fairly simple, for more complex cases it require a little bit more Javascript knowledge.

Some provided Swagger mock service [examples](https://github.com/BigstickCarpet/swagger-server/tree/master/samples) on Github.

##### Code

- `swagger-server/api-demo.js` (a Node mock server based on API spec)

#### Others

[Generic HTTP stub](https://github.com/Sensis/http-stub-server)

Interesting approach in that the server itself has an API that can be used to "teach" or "tell" it how to mock responses.

[Mule Studio](http://www.mulesoft.com/mule-studio) 

> Mule Studio is an Eclipse-based IDE that supports the creation of mock web services through APIkit, a plugin that Mule Studio's creator, MuleSoft, released last year. APIkit uses RESTful API Modeling Language (RAML), an open, vendor-neutral specification for describing REST APIs, that can be created, documented and tested using a number of open-source tools also developed by MuleSoft.

### API description languages

Why are these important:

- Serve as documentation for devs and users (more beautiful docs can be generated from it)
- Serve as code for generating mock and testing code
- Help the dev think while designing a service
- When spec is a document it becomes possible to re-use parts

See also: [Overview of RESTful API Description Languages][APIDL]

Here's a list of some of these languages:

- WSDL, been there done that, puke!
- WADL, never got off the ground possibly due to WSDL/WS* legacy
- Markdown dialect, markdown is great for human readable docs but tricky to author and parse for more complex structures.
- YAML easier to write than JSON but can still be tricky with deeply nested content.
- JSON, suitable for machines but difficult to write for humans.
- XML, can be used as a DSL and with an XML editor you get context suggestions and strict validation of document structure.
- [RAML][RAML] YAML-based.
- [Swagger][Swagger] YAML- or JSON-based. More tooling than RAML. The on-line editor is great.
- An outlier but nevertheless could be helpful as a modelling languages for "machine interactions that share a virtual state machine": [State Chart XML][SCXML]: State Machine Notation for Control Abstraction](http://www.w3.org/TR/scxml/). In a way you could define a REST service as a particular application of a State Machine.

NOTE: some solutions such as Mule Studio and Soap UI are UI focused, I tend to prefer code and text based approaches as they can be version controlled along with the implementation code.

#### Message validation

This focuses on the contract between producer and consumer. Does the producer provide a correctly structured message. This can be validated on several levels of intensity and also various moments.

- JSON-schema (used in many of the description languages)
- RelaxNG

Example: in SN XML API I always validate every message. This may be overkill but costs so little that for now I left it on.

Many APIDLs nowadays support JSON Schema. These schemas all focus on the structure of a message not the semantics.

JSON-schema is quite young compared to the tried and true Relax NG. The latter is grounded in math has a longer history.

Personally, I think that RelaxNG's compact syntax is more readable than JSON-schema syntax. I tend to use the former during design to sketch out messages. Later I can compile RelaxNG compact syntax into XML or XML-schema.

Just as Markdown dialect can be translated into JSON (but without the validations and IDE suggestions) so can XML. So even though not part of any of the above mentioned approaches if there's a JSON serialization than it is possible to write a DSL for XML, have validation (on a structural and on a business level) and editor guidance whilst still using a good documentation, mocking solution. I also claim that JSON Schema can be implemented on top of XML validation based on RelaxNG.

When:

- During development and testing
- At run-time?
- Monitoring via proxy? Wire-tapping?

#### Then there is still the matter of the semantics

XML and JSON schemas generally focus on the syntax/structure of a message. However this doesn't help much with semantics:

- When is 2015-10-10 a date and when a string? etc.

What about JSON-LD. In principle most JSON can also be expressed as JSON-LD which means we can associate it with a context to provide semantics (model).

#### Confusing the APIDL with the host language?

A lot of discussion are about the DL format. However, it is quite possible to convey the same structure in different languages. So the format that is sent over the wire does not determine the APIDL and an JSON service does not prescribes using a JSON-based APIDL.

### Conclusions

- Settle on an APIDL but allow for experiments using approaches that can work together with this APIDL (e.g. generating it from higher level descriptions).

- Select a few default tools around this APIDL but do not discourage others.

- Have a minimum set of requirements for a deployed API.

- Minimize the amount of testing via web layer. Business logic and code behind a service should be testable without going through the web layer.

- Publish docs in an accessible way (Github-like tool!!!) and for various APIs.

- Share patterns, ways of working, success or horror-stories (Company wiki!!!).

- Need to have further discussion on managing multiple APIs (Are we there yet?)

[APITOOLS]: http://www.mayerdan.com/programming/2014/01/29/investigating-api-tooling
[MOCKTOOLS]: http://www.programmableweb.com/news/top-tools-to-help-you-mock-web-services/how-to/2014/01/13
[DEMANDDRIVEN]: http://www.infoq.com/presentations/domain-driven-architecture
[FACEBOOK]: https://facebook.github.io/react/blog/2015/02/20/introducing-relay-and-graphql.html
[NETFLIX]: https://www.youtube.com/watch?v=hOE6nVVr14c
[POSTMAN]: https://www.getpostman.com
[WGET]: http://www.gnu.org/software/wget/manual/wget.html
[CURL]: http://curl.haxx.se/docs
[MOCKSERVER]: http://www.mock-server.com
[SOAPUI]: http://www.soapui.org
[SWAGGER]: http://swagger.io/
[MIREDOT]: http://www.miredot.com
[RAML]: http://raml.org
[WSDL]: http://www.w3.org/TR/wsdl
[WADL]: http://www.w3.org/Submission/wadl
[SCXML]: http://www.w3.org/TR/scxml/
[APIARY]: https://apiary.io
[APIDL]: https://en.wikipedia.org/wiki/Overview_of_RESTful_API_Description_Languages