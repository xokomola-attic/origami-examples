# Inside the guts of an Origami handler

Origami node handlers are often composed functions. Most XQuery engines will optimize these functions. So the result may look different then what you expect.

This is one of the downsides, functions are pretty opaque, like a black box. You cannot look at them as regular data. Except when the engine provides some tools for introspection into the compiled function.

For example BaseX has `prof:dump` to look into the compiled function.

As an example let's take a node transformer like this:

    let $fn := function($n,$x) { $n => o:insert($x) => o:wrap(['y']) }

This will take a node, insert the context $x into the node and then wrap that into a 'y' element.

    $fn(['x'], 'hello')

    ["y",
      ["x", "hello"]
    ]

But what happens inside this function? Let's see.

    prof:dump($fn)

    function($n_365, $x_366) as array(*) 
    { 
        (: this will ensure that the incoming node is an array :)
        let $mu_394 as array(*) := $n_365 
        (: here we know that already so code is simplified :)
        let $content_395 := 
            [((
                (: this could in theory be optimized more :)
                if ($mu_394 instance of array(*)) 
                then (array:head($mu_394)) 
                else (),
                if ((1.0 < array:size($mu_394) and $mu_394(2) instance of map(*))) 
                then ($mu_394(2)) 
                else (), 
                $x_366
            ))] 
        return 
            [((
                if(["y"] instance of array(*)) then "y" else (), $content_395
            ))] 
    }
    
Note I have added indentation and gave changed the cryptic variable names. Removed some inlined comments and some extra lines (type checking) introduced by the optimizer. Just so we can see the resulting function better. Then added some comments to show where the code was coming from.
    
    function($n, $x) as array(*) 
    { 
      (: --> o:insert :)
      let $content := 
        [
            let $n as array(*) := $n 
            (: --> o:tag :)
            if ($n instance of array(*)) 
            then array:head($n)
            else (),
            (: --> o:attributes :)
            if (1 < array:size($n) and $n(2) instance of map(*)) 
            then $n(2) 
            else (),
            $x
        ] 
      return
        (: --> o:wrap :) 
        [
            if(["y"] instance of array(*)) 
            then "y" 
            else (), 
            $content
        ] 
    }
    
The function generated by both `o:insert` looks like this:

    function($mu as array(*)) {
        array { o:tag($mu), o:attributes($mu), $content }
    }
    
The function generated by `o:wrap` looks like this:

    function($content as item()*) {
        array { o:tag($mu), o:attributes($mu), $content }
    }

Note that one variable is always absent, this is part of the closure formed by the node transformer functions.

The tag function:

    function o:tag($element as item()?)
    {
        if ($element instance of array(*)) then 
            array:head($element) 
        else 
            () 
    }

The attributes function:

    function o:attributes($element as array(*)?)
    {
        if (exists($element)
            and array:size($element) > 1 
            and $element?2 instance of map(*)) then 
            $element?2
        else 
            ()
    }

It's interesting to see which choices the optimizer has made to generate this code. For example in the `o:wrap` call it has noticed that there are no attributes on the wrapper element. On the other hand you could also say that it is obvious that `['y']` is an array so instead of the `if .. then . else` it could have generated just 'y'. But such is the thing with optimizers.

In a way we let the engine do the hard work of composing your code into a new function that could often be improved upon with manual crafted code but on the other hand you have more power (leaving the dirty work to the engine). In a way I say what I mean and let the computer figure out the details. This is especially nice because it happens at compile time and the result can be cached. More work done upfront which gives a better performance.

This type of analysis may be helpful when fine tuning code. It also points the way to performance improvements. For example if `o:insert` and `o:wrap` would already know for sure that the incoming node is always an array then some of the checks needed could be removed.
